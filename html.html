<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualizer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #particles-js {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%);
            z-index: -1;
        }

        #landing-page {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 100%;
        }

        .typewriter {
            font-size: 2.8rem;
            font-weight: bold;
            color: #6c5ce7;
            border-right: 3px solid #6c5ce7;
            white-space: nowrap;
            overflow: hidden;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .button-group {
            margin-top: 30px;
        }

        .btn {
            padding: 15px 30px;
            font-size: 16px;
            margin: 10px;
            border: none;
            border-radius: 30px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn.quick {
            background-color: #ff5e78;
        }

        .btn.merge {
            background-color: #00b894;
        }

        .btn.prim {
            background-color: #0984e3;
        }

        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        .hidden {
            display: none;
        }

        /* Visualizer containers */
        .visualizer-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding-top: 20px;
            overflow-y: auto;
        }

        /* Quick Sort Visualizer */
        #quick-sort-visualizer {
            background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%);
        }

        /* Merge Sort Visualizer */
        #merge-sort-visualizer {
            background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
        }

        /* Prim's Algorithm Visualizer */
        #prims-visualizer {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
        }

        h2 {
            margin-top: 20px;
            color: #2d3436;
            font-size: 2.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        button {
            margin: 10px;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 30px;
            border: none;
            cursor: pointer;
            background-color: #6c5ce7;
            color: white;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-weight: bold;
        }

        button:hover {
            background-color: #4e3bc0;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        /* Visualizer content styling */
        .visualizer-content {
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 15px;
            padding: 20px;
            margin: 20px auto;
            max-width: 900px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }

        /* Quick Sort Bars */
        #array-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 300px;
            margin: 30px 0;
        }

        .bar {
            width: 30px;
            margin: 2px;
            background-color: #6c5ce7;
            color: white;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
            border-radius: 5px 5px 0 0;
            position: relative;
        }

        .bar.pivot {
            background-color: #ff5e78;
            transform: scaleY(1.05);
            box-shadow: 0 0 10px rgba(255, 94, 120, 0.7);
        }

        .bar.comparing {
            background-color: #00b894;
            transform: scaleY(1.05);
            box-shadow: 0 0 10px rgba(0, 184, 148, 0.7);
        }

        .bar.sorted {
            background-color: #00cec9;
            box-shadow: 0 0 10px rgba(0, 206, 201, 0.7);
        }

        .bar.swapping {
            background-color: #fdcb6e;
            transform: scaleY(1.1);
            box-shadow: 0 0 10px rgba(253, 203, 110, 0.7);
        }

        /* Merge Sort Visualization */
        .merge-sort-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        .merge-sort-array {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 80px;
            margin: 10px 0;
            transition: all 0.3s ease;
        }

        .merge-sort-square {
            width: 40px;
            height: 40px;
            margin: 0 3px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            border-radius: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.16);
        }

        .merge-sort-square.unsorted {
            background-color: #2d3436;
        }

        .merge-sort-square.left-array {
            background-color: #6c5ce7;
        }

        .merge-sort-square.right-array {
            background-color: #00b894;
        }

        .merge-sort-square.comparing {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            z-index: 1;
        }

        .merge-sort-square.selected {
            background-color: #fdcb6e;
            transform: translateY(-10px);
        }

        .merge-sort-square.sorted {
            background-color: #00cec9;
        }

        .merge-sort-square.merged {
            background-color: #0984e3;
        }

        .merge-sort-label {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #2d3436;
        }

        .merge-animation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .merge-stages {
            display: flex;
            flex-direction: column;
            width: 100%;
            align-items: center;
        }

        .comparison-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            gap: 20px;
        }

        .comparison-arrow {
            font-size: 24px;
            color: #ff5e78;
            font-weight: bold;
        }

        /* Prim's Algorithm Visualizer */
        .graph-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
        }

        #graphCanvas {
            border: 2px solid #555;
            background-color: #f8f8f8;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        #graphCanvas:hover {
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .queue-container {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-top: 20px;
        }

        .queue-title {
            font-weight: bold;
            color: #6c5ce7;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .queue-items {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .queue-item {
            background-color: #0984e3;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-panel {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 15px;
            margin: 15px auto;
            max-width: 600px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .info-panel h3 {
            margin-top: 0;
            color: #6c5ce7;
        }

        .info-panel p {
            margin-bottom: 0;
            color: #2d3436;
        }

        .step-info {
            font-weight: bold;
            color: #0984e3;
            margin: 10px 0;
            text-align: center;
            min-height: 24px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .typewriter {
                font-size: 1.8rem;
            }
            
            .btn {
                padding: 12px 24px;
                font-size: 14px;
            }
            
            .visualizer-content {
                margin: 20px;
                padding: 15px;
            }
            
            #graphCanvas {
                width: 90%;
                height: 300px;
            }
            
            .merge-sort-square {
                width: 30px;
                height: 30px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Particle background -->
    <div id="particles-js"></div>

    <!-- Landing Page -->
    <div id="landing-page">
        <h1><span class="typewriter"></span></h1>
        <div class="button-group">
            <button class="btn quick" onclick="showQuickSortVisualizer()">Quick Sort</button>
            <button class="btn merge" onclick="showMergeSortVisualizer()">Merge Sort</button>
            <button class="btn prim" onclick="showPrimsVisualizer()">Prim's Algorithm</button>
        </div>
    </div>

    <!-- Quick Sort Visualizer -->
    <div id="quick-sort-visualizer" class="visualizer-container hidden">
        <div class="visualizer-content">
            <h2>Quick Sort Visualizer</h2>
            
            <div class="info-panel">
                <h3>Quick Sort Algorithm</h3>
                <p>Quick Sort is a divide-and-conquer algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. This is one of the most efficient sorting algorithms with average time complexity of O(n log n).</p>
            </div>
            
            <div class="controls">
                <button onclick="runQuickSort()">Start Quick Sort</button>
                <button onclick="resetQuickSort()">Reset</button>
                <div class="speed-control">
                    <label for="speed">Speed:</label>
                    <select id="speed" onchange="changeSpeed()">
                        <option value="1000">Slow</option>
                        <option value="500" selected>Medium</option>
                        <option value="200">Fast</option>
                    </select>
                </div>
            </div>
            <div id="array-container"></div>
            <button onclick="goBackHome()">Back to Home</button>
        </div>
    </div>

    <!-- Merge Sort Visualizer -->
    <div id="merge-sort-visualizer" class="visualizer-container hidden">
        <div class="visualizer-content">
            <h2>Merge Sort Visualizer</h2>
            
            <div class="info-panel">
                <h3>Merge Sort Algorithm</h3>
                <p>Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts each half, and then merges the two sorted halves. The key operation is the merge process, which combines two sorted arrays into a single sorted array.</p>
            </div>
            
            <div class="controls">
                <button onclick="runMergeSort()">Start Merge Sort</button>
                <div class="speed-control">
                    <label for="merge-speed">Speed:</label>
                    <select id="merge-speed" onchange="changeMergeSpeed()">
                        <option value="1000">Slow</option>
                        <option value="600" selected>Medium</option>
                        <option value="300">Fast</option>
                    </select>
                </div>
            </div>
            
            <div id="step-info" class="step-info">Click "Start Merge Sort" to begin visualization</div>
            
            <div class="merge-animation-container">
                <div id="original-array-container" class="merge-stages">
                    <div class="merge-sort-label">Original Array</div>
                    <div class="merge-sort-array" id="original-array"></div>
                </div>
                <div id="split-container" class="merge-stages hidden">
                    <div class="merge-sort-label">Splitting</div>
                    <div class="merge-sort-array" id="left-array"></div>
                    <div class="merge-sort-array" id="right-array"></div>
                </div>
                <div id="comparison-container" class="comparison-container hidden">
                    <div class="merge-sort-array" id="left-comparison"></div>
                    <div class="comparison-arrow">↔</div>
                    <div class="merge-sort-array" id="right-comparison"></div>
                </div>
                <div id="merge-container" class="merge-stages hidden">
                    <div class="merge-sort-label">Merging</div>
                    <div class="merge-sort-array" id="merge-result-array"></div>
                </div>
                <div id="final-array-container" class="merge-stages hidden">
                    <div class="merge-sort-label">Sorted Array</div>
                    <div class="merge-sort-array" id="final-array"></div>
                </div>
            </div>
            <button onclick="goBackHome()">Back to Home</button>
        </div>
    </div>

    <!-- Prim's Algorithm Visualizer -->
    <div id="prims-visualizer" class="visualizer-container hidden">
        <div class="visualizer-content">
            <h2>Prim's Algorithm Visualizer</h2>
            
            <div class="info-panel">
                <h3>Prim's Algorithm</h3>
                <p>Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. It starts with an arbitrary node and grows the spanning tree by adding the cheapest edge from the tree to another node until all nodes are included.</p>
            </div>
            
            <div class="controls">
                <button onclick="runPrims()">Run Prim's Algorithm</button>
                <button onclick="resetPrims()">Reset</button>
                <div class="speed-control">
                    <label for="prim-speed">Speed:</label>
                    <select id="prim-speed" onchange="changePrimSpeed()">
                        <option value="1500">Slow</option>
                        <option value="800" selected>Medium</option>
                        <option value="400">Fast</option>
                    </select>
                </div>
            </div>
            
            <div id="step-info" class="step-info">Click "Run Prim's Algorithm" to start visualization</div>
            
            <div class="graph-container">
                <canvas id="graphCanvas" width="700" height="400"></canvas>
                <div class="queue-container">
                    <div class="queue-title">Priority Queue:</div>
                    <div id="queue-items" class="queue-items"></div>
                </div>
            </div>
            
            <button onclick="goBackHome()">Back to Home</button>
        </div>
    </div>

    <!-- Particles.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/particles.js"></script>

    <script>
        // Global variables
        let array = [45, 12, 78, 34, 23, 9, 66, 89]; // Example array
        let originalArray = [...array]; // Store the original array
        let animationSpeed = 500; // Default speed for Quick Sort
        let mergeAnimationSpeed = 600; // Default speed for Merge Sort
        let primAnimationSpeed = 800; // Default speed for Prim's Algorithm

        // Show Quick Sort Visualizer
        function showQuickSortVisualizer() {
            document.getElementById("landing-page").classList.add("hidden");
            document.getElementById("quick-sort-visualizer").classList.remove("hidden");
            resetQuickSort();
        }

        // Show Merge Sort Visualizer
        function showMergeSortVisualizer() {
            document.getElementById("landing-page").classList.add("hidden");
            document.getElementById("merge-sort-visualizer").classList.remove("hidden");
            drawOriginalArray();
        }

        // Show Prim's Algorithm Visualizer
        function showPrimsVisualizer() {
            document.getElementById("landing-page").classList.add("hidden");
            document.getElementById("prims-visualizer").classList.remove("hidden");
            resetPrims();
        }

        // Go back to Home
        function goBackHome() {
            document.getElementById("quick-sort-visualizer").classList.add("hidden");
            document.getElementById("merge-sort-visualizer").classList.add("hidden");
            document.getElementById("prims-visualizer").classList.add("hidden");
            document.getElementById("landing-page").classList.remove("hidden");
        }

        // Reset the array to its original state
        function resetArray() {
            array = [...originalArray];
        }

        // Reset Quick Sort specifically
        function resetQuickSort() {
            resetArray();
            drawArray(array);
        }

        // Change animation speed for Quick Sort
        function changeSpeed() {
            animationSpeed = parseInt(document.getElementById("speed").value);
        }

        // Change animation speed for Merge Sort
        function changeMergeSpeed() {
            mergeAnimationSpeed = parseInt(document.getElementById("merge-speed").value);
        }

        // Change animation speed for Prim's Algorithm
        function changePrimSpeed() {
            primAnimationSpeed = parseInt(document.getElementById("prim-speed").value);
        }

        // Draw array for Quick Sort with highlighting
        function drawArray(arr, highlights = {}) {
            const container = document.getElementById("array-container");
            container.innerHTML = ''; // Clear previous bars
            
            arr.forEach((value, index) => {
                const bar = document.createElement("div");
                bar.classList.add("bar");
                bar.style.height = `${value * 3}px`;
                bar.innerText = value;
                
                // Apply highlighting based on the current operation
                if (highlights.pivot === index) {
                    bar.classList.add("pivot");
                } else if (highlights.comparing === index) {
                    bar.classList.add("comparing");
                } else if (highlights.sorted && highlights.sorted.includes(index)) {
                    bar.classList.add("sorted");
                } else if (highlights.swapping && (highlights.swapping.i === index || highlights.swapping.j === index)) {
                    bar.classList.add("swapping");
                }
                
                container.appendChild(bar);
            });
        }

        // Draw original array for Merge Sort
        function drawOriginalArray() {
            const container = document.getElementById("original-array");
            container.innerHTML = '';
            
            array.forEach(value => {
                const square = document.createElement("div");
                square.classList.add("merge-sort-square", "unsorted");
                square.textContent = value;
                container.appendChild(square);
            });
            
            // Hide all other containers
            document.getElementById("split-container").classList.add("hidden");
            document.getElementById("comparison-container").classList.add("hidden");
            document.getElementById("merge-container").classList.add("hidden");
            document.getElementById("final-array-container").classList.add("hidden");
            
            document.getElementById("step-info").textContent = "Click 'Start Merge Sort' to begin visualization";
        }

        // Draw left/right arrays during split phase
        function drawSplitArrays(left, right) {
            document.getElementById("split-container").classList.remove("hidden");
            document.getElementById("comparison-container").classList.add("hidden");
            
            const leftContainer = document.getElementById("left-array");
            const rightContainer = document.getElementById("right-array");
            
            leftContainer.innerHTML = '';
            rightContainer.innerHTML = '';
            
            left.forEach(value => {
                const square = document.createElement("div");
                square.classList.add("merge-sort-square", "left-array");
                square.textContent = value;
                leftContainer.appendChild(square);
            });
            
            right.forEach(value => {
                const square = document.createElement("div");
                square.classList.add("merge-sort-square", "right-array");
                square.textContent = value;
                rightContainer.appendChild(square);
            });
        }

        // Draw comparison between two elements
        async function drawComparison(leftValue, rightValue, leftIndex, rightIndex) {
            document.getElementById("comparison-container").classList.remove("hidden");
            
            const leftContainer = document.getElementById("left-comparison");
            const rightContainer = document.getElementById("right-comparison");
            
            leftContainer.innerHTML = '';
            rightContainer.innerHTML = '';
            
            // Create left comparison element
            const leftSquare = document.createElement("div");
            leftSquare.classList.add("merge-sort-square", "left-array", "comparing");
            leftSquare.textContent = leftValue;
            leftContainer.appendChild(leftSquare);
            
            // Create right comparison element
            const rightSquare = document.createElement("div");
            rightSquare.classList.add("merge-sort-square", "right-array", "comparing");
            rightSquare.textContent = rightValue;
            rightContainer.appendChild(rightSquare);
            
            // Update step info
            document.getElementById("step-info").textContent = 
                `Comparing ${leftValue} (left) with ${rightValue} (right)`;
            
            await sleep(mergeAnimationSpeed / 2);
        }

        // Draw merge result
        function drawMergeResult(result, leftIndex, rightIndex) {
            document.getElementById("comparison-container").classList.add("hidden");
            document.getElementById("merge-container").classList.remove("hidden");
            const container = document.getElementById("merge-result-array");
            container.innerHTML = '';
            
            result.forEach((value, index) => {
                const square = document.createElement("div");
                square.classList.add("merge-sort-square", "merged");
                square.textContent = value;
                
                if (index === leftIndex || index === rightIndex) {
                    square.classList.add("selected");
                }
                
                container.appendChild(square);
            });
            
            return new Promise(resolve => {
                setTimeout(resolve, mergeAnimationSpeed / 2);
            });
        }

        // Draw final sorted array
        function drawFinalArray(sortedArray) {
            document.getElementById("merge-container").classList.add("hidden");
            document.getElementById("final-array-container").classList.remove("hidden");
            const container = document.getElementById("final-array");
            container.innerHTML = '';
            
            sortedArray.forEach(value => {
                const square = document.createElement("div");
                square.classList.add("merge-sort-square", "sorted");
                square.textContent = value;
                container.appendChild(square);
            });
        }

        // Sleep function to slow down animations
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- QuickSort Visualization ---
        async function quickSort(arr, low, high, sortedIndices = []) {
            if (low < high) {
                // Highlight the current partition
                drawArray(arr, { sorted: sortedIndices });
                await sleep(animationSpeed);
                
                let pivotIndex = await partition(arr, low, high, sortedIndices);
                
                // Add pivot to sorted indices
                sortedIndices.push(pivotIndex);
                
                await quickSort(arr, low, pivotIndex - 1, sortedIndices);
                await quickSort(arr, pivotIndex + 1, high, sortedIndices);
            }
            
            // When fully sorted, highlight all bars
            if (low === 0 && high === arr.length - 1) {
                drawArray(arr, { sorted: Array.from({length: arr.length}, (_, i) => i) });
            }
        }

        async function partition(arr, low, high, sortedIndices) {
            let pivot = arr[high];
            let i = low - 1;
            
            // Highlight pivot element
            drawArray(arr, { 
                pivot: high,
                sorted: sortedIndices
            });
            await sleep(animationSpeed);
            
            for (let j = low; j < high; j++) {
                // Highlight comparing elements
                drawArray(arr, {
                    pivot: high,
                    comparing: j,
                    sorted: sortedIndices
                });
                await sleep(animationSpeed);
                
                if (arr[j] < pivot) {
                    i++;
                    
                    // Highlight swapping elements
                    if (i !== j) {
                        drawArray(arr, {
                            pivot: high,
                            swapping: {i, j},
                            sorted: sortedIndices
                        });
                        await sleep(animationSpeed);
                    }
                    
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                    
                    // Show after swap
                    drawArray(arr, {
                        pivot: high,
                        sorted: sortedIndices
                    });
                    await sleep(animationSpeed);
                }
            }
            
            // Final swap with pivot
            drawArray(arr, {
                pivot: high,
                swapping: {i: i+1, j: high},
                sorted: sortedIndices
            });
            await sleep(animationSpeed);
            
            [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            
            // Show final state of this partition
            drawArray(arr, {
                sorted: [...sortedIndices, i + 1]
            });
            await sleep(animationSpeed);
            
            return i + 1;
        }

        async function runQuickSort() {
            const startBtn = document.querySelector('#quick-sort-visualizer button:nth-of-type(1)');
            startBtn.disabled = true;
            try {
                await quickSort(array, 0, array.length - 1);
                alert("✅ Quick Sort completed!");
            } finally {
                startBtn.disabled = false;
            }
        }

        // --- Enhanced MergeSort Visualization ---
        async function mergeSort(arr, depth = 0) {
            if (arr.length <= 1) return arr;

            // Show splitting animation
            if (depth === 0) {
                await sleep(mergeAnimationSpeed);
                drawOriginalArray();
                await sleep(mergeAnimationSpeed);
            }

            const mid = Math.floor(arr.length / 2);
            const left = arr.slice(0, mid);
            const right = arr.slice(mid);

            // Visualize the split
            if (depth === 0) {
                drawSplitArrays(left, right);
                document.getElementById("step-info").textContent = "Splitting array into two halves";
                await sleep(mergeAnimationSpeed * 1.5);
            }

            // Recursively sort both halves
            const sortedLeft = await mergeSort(left, depth + 1);
            const sortedRight = await mergeSort(right, depth + 1);

            // Merge the sorted halves with visualization
            return await merge(sortedLeft, sortedRight, depth);
        }

        async function merge(left, right, depth) {
            const result = [];
            let i = 0, j = 0;

            // Show merging process only for top-level calls
            if (depth === 0) {
                document.getElementById("merge-container").classList.remove("hidden");
                document.getElementById("step-info").textContent = "Merging sorted halves";
            }

            while (i < left.length && j < right.length) {
                // Highlight the elements being compared
                if (depth === 0) {
                    await drawComparison(left[i], right[j], i, j);
                    
                    // Show which element is being selected
                    if (left[i] < right[j]) {
                        document.getElementById("step-info").textContent = 
                            `${left[i]} (left) is smaller → adding to result`;
                    } else {
                        document.getElementById("step-info").textContent = 
                            `${right[j]} (right) is smaller → adding to result`;
                    }
                    await sleep(mergeAnimationSpeed / 2);
                }

                if (left[i] < right[j]) {
                    result.push(left[i]);
                    i++;
                } else {
                    result.push(right[j]);
                    j++;
                }

                // Show the current merge state
                if (depth === 0) {
                    await drawMergeResult([...result, ...left.slice(i), ...right.slice(j)], i, j);
                    await sleep(mergeAnimationSpeed / 2);
                }
            }

            // Add remaining elements
            result.push(...left.slice(i));
            result.push(...right.slice(j));

            // Show final merge state for this step
            if (depth === 0) {
                await drawMergeResult(result, -1, -1);
                await sleep(mergeAnimationSpeed);
            }

            return result;
        }

        async function runMergeSort() {
            const startBtn = document.querySelector('#merge-sort-visualizer button:nth-of-type(1)');
            startBtn.disabled = true;
            try {
                // Reset visualization
                drawOriginalArray();
                document.getElementById("step-info").textContent = "Starting Merge Sort...";
                await sleep(mergeAnimationSpeed);

                // Run the sort
                const sortedArray = await mergeSort(array);

                // Show final result
                document.getElementById("step-info").textContent = "✅ Merge Sort completed!";
                drawFinalArray(sortedArray);
                array = sortedArray;
                await sleep(mergeAnimationSpeed);
            } finally {
                startBtn.disabled = false;
            }
        }

        // --- Enhanced Prim's Algorithm Visualization ---
        const graph = {
            0: [[1, 4], [7, 8]],
            1: [[0, 4], [2, 8], [7, 11]],
            2: [[1, 8], [3, 7], [5, 4], [8, 2]],
            3: [[2, 7], [4, 9], [5, 14]],
            4: [[3, 9], [5, 10]],
            5: [[2, 4], [3, 14], [4, 10], [6, 2]],
            6: [[5, 2], [7, 1], [8, 6]],
            7: [[0, 8], [1, 11], [6, 1], [8, 7]],
            8: [[2, 2], [6, 6], [7, 7]],
        };

        const positions = {
            0: [100, 100],
            1: [300, 100],
            2: [500, 100],
            3: [600, 200],
            4: [600, 300],
            5: [400, 250],
            6: [200, 250],
            7: [100, 200],
            8: [300, 200],
        };

        let mstEdges = [];
        let visitedNodes = new Set();
        let activeEdge = null;
        let currentNode = null;
        let queueContents = [];

        function drawGraph() {
            const canvas = document.getElementById("graphCanvas");
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw all edges first (so nodes appear on top)
            const drawnEdges = new Set();

            for (const u in graph) {
                for (const [v, weight] of graph[u]) {
                    const key = `${Math.min(u, v)}-${Math.max(u, v)}`;
                    if (drawnEdges.has(key)) continue;
                    drawnEdges.add(key);

                    const [x1, y1] = positions[u];
                    const [x2, y2] = positions[v];

                    // Check if this is the active edge being considered
                    const isActiveEdge = activeEdge && 
                        ((activeEdge[0] == u && activeEdge[1] == v) || 
                         (activeEdge[0] == v && activeEdge[1] == u));

                    // Check if this edge is in MST
                    const isMSTEdge = mstEdges.some(([a, b]) => 
                        (a == u && b == v) || (a == v && b == u));

                    // Draw edge
                    ctx.strokeStyle = isActiveEdge ? "#ff5e78" : 
                                      isMSTEdge ? "#6c5ce7" : "#ccc";
                    ctx.lineWidth = isActiveEdge ? 4 : (isMSTEdge ? 3 : 1);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();

                    // Draw weight
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    ctx.fillStyle = isActiveEdge ? "#ff5e78" : "#2d3436";
                    ctx.font = "bold 12px Arial";
                    ctx.fillText(weight, midX, midY);
                }
            }

            // Draw nodes
            for (const node in positions) {
                const [x, y] = positions[node];
                
                // Check if this is the current node being processed
                const isCurrentNode = currentNode == node;
                
                // Check if node is visited
                const isVisited = visitedNodes.has(node);
                
                // Draw node circle
                ctx.fillStyle = isCurrentNode ? "#ff5e78" : 
                                 isVisited ? "#00b894" : "#0984e3";
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, 2 * Math.PI);
                ctx.fill();
                
                // Add glow effect for current node
                if (isCurrentNode) {
                    ctx.shadowColor = "#ff5e78";
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                // Draw node label
                ctx.fillStyle = "white";
                ctx.font = "bold 14px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(node, x, y);
            }
        }

        function drawQueue() {
            const container = document.getElementById("queue-items");
            container.innerHTML = '';
            
            queueContents.forEach(item => {
                const [u, v] = item.element;
                const weight = item.priority;
                
                const queueItem = document.createElement("div");
                queueItem.classList.add("queue-item");
                queueItem.textContent = `${u}-${v} (${weight})`;
                container.appendChild(queueItem);
            });
        }

        function updateStepInfo(text) {
            document.getElementById("step-info").textContent = text;
        }

        class MinPriorityQueue {
            constructor() {
                this.queue = [];
            }

            enqueue(element, priority) {
                this.queue.push({ element, priority });
                this.queue.sort((a, b) => a.priority - b.priority);
            }

            dequeue() {
                return this.queue.shift();
            }

            isEmpty() {
                return this.queue.length === 0;
            }

            getContents() {
                return [...this.queue];
            }
        }

        function resetPrims() {
            mstEdges = [];
            visitedNodes = new Set();
            activeEdge = null;
            currentNode = null;
            queueContents = [];
            updateStepInfo("Graph reset. Click 'Run Prim's Algorithm' to start visualization");
            drawGraph();
            drawQueue();
        }

        async function runPrims() {
            const startBtn = document.querySelector('#prims-visualizer button:nth-of-type(1)');
            startBtn.disabled = true;
            try {
                // Reset visualization
                mstEdges = [];
                visitedNodes = new Set();
                activeEdge = null;
                currentNode = null;
                queueContents = [];
                drawGraph();
                drawQueue();
                
                updateStepInfo("Starting Prim's algorithm...");
                await sleep(primAnimationSpeed / 2);
                
                const pq = new MinPriorityQueue();

                // Start with node 0
                let start = 0;
                visitedNodes.add(start);
                currentNode = start;
                updateStepInfo(`Adding node ${start} to MST`);
                drawGraph();
                await sleep(primAnimationSpeed);
                
                // Add all edges from start node to priority queue
                for (const [v, w] of graph[start]) {
                    pq.enqueue([start, v], w);
                    queueContents = pq.getContents();
                    updateStepInfo(`Adding edge ${start}-${v} (weight ${w}) to priority queue`);
                    activeEdge = [start, v];
                    drawGraph();
                    drawQueue();
                    await sleep(primAnimationSpeed / 2);
                }
                
                activeEdge = null;
                drawGraph();
                
                while (!pq.isEmpty()) {
                    // Get the edge with minimum weight
                    const { element: [u, v] } = pq.dequeue();
                    queueContents = pq.getContents();
                    drawQueue();
                    
                    // Highlight the edge being considered
                    activeEdge = [u, v];
                    currentNode = v;
                    updateStepInfo(`Considering edge ${u}-${v} (minimum weight in queue)`);
                    drawGraph();
                    await sleep(primAnimationSpeed);
                    
                    if (visitedNodes.has(v)) {
                        updateStepInfo(`Node ${v} already in MST - skipping this edge`);
                        activeEdge = null;
                        drawGraph();
                        await sleep(primAnimationSpeed / 2);
                        continue;
                    }
                    
                    // Add edge to MST
                    mstEdges.push([u, v]);
                    visitedNodes.add(v);
                    updateStepInfo(`Adding edge ${u}-${v} to MST and node ${v} to visited set`);
                    drawGraph();
                    await sleep(primAnimationSpeed);
                    
                    // Add all edges from v to priority queue
                    for (const [to, weight] of graph[v]) {
                        if (!visitedNodes.has(to)) {
                            pq.enqueue([v, to], weight);
                            queueContents = pq.getContents();
                            updateStepInfo(`Adding edge ${v}-${to} (weight ${weight}) to priority queue`);
                            activeEdge = [v, to];
                            drawGraph();
                            drawQueue();
                            await sleep(primAnimationSpeed / 2);
                        }
                    }
                    
                    activeEdge = null;
                    drawGraph();
                    await sleep(primAnimationSpeed / 2);
                }
                
                updateStepInfo("✅ Prim's Algorithm completed! Minimum Spanning Tree found.");
                alert("✅ Prim's Algorithm completed!");
            } finally {
                startBtn.disabled = false;
            }
        }

        // Typewriter effect
        const text = "Welcome to Algorithm Visualizer";
        const typeSpan = document.querySelector(".typewriter");
        let index = 0;

        function type() {
            if (index < text.length) {
                typeSpan.textContent += text.charAt(index);
                index++;
                setTimeout(type, 100);
            }
        }

        type();

        // Particle.js Config
        particlesJS("particles-js", {
            "particles": {
                "number": { "value": 60, "density": { "enable": true, "value_area": 800 }},
                "color": { "value": "#ffffff" },
                "shape": { "type": "circle", "stroke": { "width": 0, "color": "#000000" }},
                "opacity": { "value": 0.5, "random": false },
                "size": { "value": 4, "random": true },
                "line_linked": {
                    "enable": true,
                    "distance": 150,
                    "color": "#ffffff",
                    "opacity": 0.4,
                    "width": 1
                },
                "move": {
                    "enable": true,
                    "speed": 2,
                    "direction": "none",
                    "random": false,
                    "straight": false,
                    "out_mode": "bounce"
                }
            },
            "interactivity": {
                "detect_on": "canvas",
                "events": {
                    "onhover": { "enable": true, "mode": "repulse" },
                    "onclick": { "enable": true, "mode": "push" }
                },
                "modes": {
                    "repulse": { "distance": 100, "duration": 0.4 },
                    "push": { "particles_nb": 4 }
                }
            },
            "retina_detect": true
        });

        // Initialize visualizations
        showQuickSortVisualizer = function() {
            document.getElementById("landing-page").classList.add("hidden");
            document.getElementById("quick-sort-visualizer").classList.remove("hidden");
            resetQuickSort();
        };

        showMergeSortVisualizer = function() {
            document.getElementById("landing-page").classList.add("hidden");
            document.getElementById("merge-sort-visualizer").classList.remove("hidden");
            drawOriginalArray();
        };

        showPrimsVisualizer = function() {
            document.getElementById("landing-page").classList.add("hidden");
            document.getElementById("prims-visualizer").classList.remove("hidden");
            resetPrims();
        };

        // Initial setup
        window.onload = function() {
            drawOriginalArray();
        };
    </script>
</body>
</html>